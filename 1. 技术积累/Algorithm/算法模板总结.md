# 算法模板总结

## DFS

```c++
void dfs(int u){
    // 边界条件，举个例子如下
    if(u == n){
        // 处理到达边界时的情况
    }
    // 搜索逻辑，这里比较灵活，剪枝优化应在此处
    
}
int main(){
    dfs(0); // 或者是dfs(0,0) dfs(0,0,0)取决于搜索的方式
}
```

经典问题： 全排列，n皇后

## BFS

```c++
#include<queue>

void bfs(){
    // 初始化队列
    queue<int> q;
    q.push(1);
    // bfs 遍历队列
    while(q.size()){
        auto t = q.front();
        q.pop();
        // 处理t,push新内容
    }
}

// 数组模拟队列写法
void bfs(){
    int q[N];
    int hh = 0, tt = 0;
    while(hh <= tt){
        int t = q[hh++];
        q[++tt] = newdata;
    }
}
```

经典问题：迷宫问题

DFS也可以求出迷宫的解，但是回溯的过程比较麻烦，而BFS搜索得会更快（DFS会花费大量时间去走一条思路，在死路中回溯也要回溯很久）

边权为1时，BFS可以用来求解最短路径，否则用dijsktra

## 双指针

核心思想：将O（n^2）复杂度转为O（n）

```C++
for (i = 0, j = 0; i < n; i++)
{
    while(j < i && check(i, j))j++;
    //每道题的具体逻辑
}
```



# 树图

## 表示方式


1. 首先将树视为特殊的图  可以统一用邻接表方式建树建图

   ```c++
   #include<iostream>
   #include<cstring>
   const int N = 10010;
   int e[N], ne[N], h[N], idx;
   
   void add(int a, int b){
       e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
   }
   
   // 遍历结点u的邻接表
   for(int i = h[u]; ~i; i = ne[i]){
       int j = e[j];  // 接下来对 j 结点进行处理
   }
   ```

   普通二叉树 可以用如下程序存储

   ```c++
   const int N = 40;
   int l[N], r[N], q[N];
   ```

   完全二叉树可以用一个一维数组存储

   ```c++
   const int N = 10010;
   int tr[N];
   ```

2. 中序 + 后序（前序）可以得到确定的一棵树，一个BST的中序遍历必然是一个有序序列

   ```c++
   
   ```

3. 拓扑排序

   ```c++
   bool topsort(){
       int hh = 0, tt = 0;
       for(int i = 1; i <= n; i++){
           if(d[i] == 0)q[tt++] = i;  //tt已经把所有0入度结点放进去
       }
       while(hh <= tt){
           int t = q[hh++];
           for(int i = h[t]; i != -1; i = ne[i]){
               int j = e[i]; //e里面放了 结点号 1-n 而h里面放了idx是从 0 - ~
               if(--d[j] == 0)q[tt++] = j; //如果sort过程中出现了0 再次放进去
           }
       }
       if(tt == n)return true;
       return false;
   }
   int main(){
       while(m--){
           int a, b;
           cin >> a >> b;
           add(a, b);
           d[b]++;
       }
       if(topsort()){
           for(int i = 0; i < n; i++)cout << q[i] << " ";
       }
       else{
           cout << "-1";
       }
       return 0;
   }
   ```

4. 建图时 统一用有向图， 将无向图视为特殊的有向图，即每一条无向边都用两条有向边表示

5. dijkstra 算法在建图时， 若存在 重边、自环 ，稠密图用邻接矩阵存储，对于自环，不可能出现在最短路径中，只要在输入边时不载入图即可，对于重边，只需要保留最短的边即可

   ```c++
   #include<iostream>
   #include<cstring>
   using namespace std;
   const int N = 510;
   int g[N][N], dist[N], n, m;
   bool st[N];
   int dijkstra(){
       memset(dist, 0x3f, sizeof dist);
       dist[1] = 0;
       for(int i = 0; i < n; i++){
           int t = -1;
           for(int j = 1; j <= n; j++)
               if(!st[j] && (t == -1 || dist[j] < dist[t]))t = j;
           st[t] = true;
           for(int j = 1; j <= n; j++)
               if(!st[j])dist[j] = min(dist[j], dist[t] + g[t][j]);
       }
       if(dist[n] == 0x3f3f3f3f)return -1;
       return dist[n];
   }
   int main(){
       cin >> n >> m;
       memset(g, 0x3f, sizeof g);
       int a, b, c;
       while(m--){
           cin >> a >> b >> c;
           g[a][b] = min(g[a][b], c);
       }
       cout << dijkstra();
   }
   ```

6. BST 给定一序列 如何建树（递归insert，要用到idx，带引用） 如何计算BST每一层的深度（dfs先序记录）

   ```c++
   const int N = 1010;
   int n;
   int l[N], r[N], v[N], idx;
   int maxdepth, cnt[N];
   void insert(int& u, int w){//这里u加了引用并且main函数中要定义一个root=0,不能直接insert(0, w)
       if(!u){
           u = ++idx;		// idx给新插入的结点 授予索引号
           v[u] = w;
       }
       else if(w <= v[u]){
           insert(l[u], w);	//由int& u 在递归的掉用过程中就建立起来父亲孩子关系，更新了l,r数组
       }
       else{
           insert(r[u], w);
       }
       return;
   }
   int main(){
       cin >> n;
       int root = 0; // 这是为了使得递归的规则圆满
       while(n--){
           int w;
           cin >> w;
           insert(root, w);
       }
       dfs(root, 0);
       int n1 = cnt[maxdepth];
       int n2 = cnt[maxdepth - 1];
       printf("%d + %d = %d", n1, n2, n1 + n2);
       return 0;
   }
   ```

   

   