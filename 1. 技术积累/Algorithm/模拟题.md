>1. 辗转相除法求最⼤公约数：
>
>> ```C++
>> int gcd(int a, int b){
>	return b ? gcd(b, a % b) : a; 
>}
>> ```
>
>
>2. cctype ⾥⾯： isalnum 是字⺟数字； isalpha 是字⺟； isdigit 是数字； isupper 是⼤写字
>    ⺟； islower 是⼩写字⺟； isblank 是空格/tab键； isspace 是空格/tab键/回⻋
>
>```c++
>#include<cctype>
>isalnum();
>isalpha();
>isdigit();
>isupper();
>islower();
>isblank();
>isspace();
>// char 或 string 变成小写
>char a = 'A';
>char b = tolower(a);  // 方式一
>char c = 'A' + 32;
>```
>
>3.  变量上限问题 INF
>
>```c++
>#include<climits>
>typedef long long LL;
>LL a;
>int max = INT_MAX; //int 最大值 `21,4748,3647`共10位数字，故超过`10^9`就需要用到字符串
>int min = INT_MIN;
>LL max = LLONG_MAX; // 最⼤值有19位数字，以9开头，即9*1e18,大于19位只能用字符串
>// 所以比如1010Radix题中 进制转换时，计算可能会爆掉
>if ((double)a > 1e16) return 1e18; // 处理LL可能会爆的问题，double比LL位数更多，精度更低
>```
>
>4. 储存13位的学号可以⽤ long long int ，输出的时候使⽤ %013lld， 013是指不足13用0补充，lld指的是long long int 类型。
>
>```c++
>typedef long long LL;
>LL id;
>printf("%013lld", id);
>```
>
>5. sort排序 重载运算顺序 及 结构体重载运算符 及结构体相关
>
>```c++
>#include<iostream>
>#include<vector>
>#include<algorithm>
>using namespace std;
>//运算符重载 < 这个是改变比较的元素
>const int N = 10010;
>struct Person{  //对于struct结构体何时使用的理解，当信息较杂时使用，有id这种主键时亦可用map替代
>     int arrive_time;
>     int leave_time;
>     // 重载的 > 规则会在sort时cmp为升序，或者定义有限队列时 参数为less时被使用
>     // priority_queue<Person, vector<Person>, less<Person>> q
>     bool operator < (const Person& t) const{
>         return arrive_time < t.arrive_time;
>     }
>     // 重载的 > 规则会在sort时cmp为降序，或者定义有限队列时 参数为greater时被使用
>     // priority_queue<Person, vector<Person>, greater<Person>> q
>     bool operator > (const Person& t) const{
>         return leave_time > t.leave_time;	
>     }
>}persons[N];
>sort(persons, persons + N, cmp); //按照arrive_time 升序排序
>sort(persons, persons + N, cmp); //按照leave_time 降序排序
>//运算符重载 cmp 这个是改变调用sort时 升序or降序
>int main(){
>    vector<int> v;
>    sort(v.begin(), v.end(), cmp);
>    string s;
>    sort(s.begin(), s.end(), cmp);
>    int a[10];
>    sort(a, a + n, cmp);
>    return 0;
>}
>//结构体可以用unordered_map 哈希表来实现相似的作用
>//这是一个记录学生信息的结构体数组  特点为 id 为主键，其余成绩都为int类型
>struct student{
>     string id;
>     int ga, gm, ge, avg;
> }students[2001];
>//下面是定义一个哈希表
>unordered_map<string, vector<int>> grades;
>//比较两者 发现哈希表可以由id快速定位某个学生，而结构体数组不行
>// 但是哈希表仅在其余元素为同一类型时比较方便，并且此时 int 型的众多变量由vector存储更方便
>```
>
>6. 关
>
>```c++
>
>```
>
>7. 关于vector 和 int a[] 选用哪个的问题 ， 总之尽量用 vector
>
> ```c++
>#include<iostream>
>#include<vector>
>using namespace std;
>int main(){
>  vector<int> v1;
>  vector<int> v2;
>  v1.push_back(5);
>  v1.push_back(2);
>  v2.push_back(4);
>  v2.push_back(3);
>  // vector 会自动扩充无需指定大小，但是带来的代价是速度更慢
>  //vector 可以比较大小, 比大小原则为：从索引0开始，依次向后逐个比较元素大小
>  if(v1 < v2){
>       cout << " v1 < v2";
>   }
>   if(v1 > v2){
>       cout << " v1 > v2";
>   }
>   if(v1 == v2){
>       cout << " v1 == v2";
>   }
> }
> //vector可以逆置
> vector<int> a;
> vector<int> b(a.rbegin(), a.rend()); //定义时逆置
> ```
> 
> 8. 优先队列的使用
> 
>```c++
>#include<priority_queue>
>using namespace std;
>//定义
>priority_queue<int, vector<int>, greater<int>> windows;
>typedef INF = 100000;
>windows.push(INF);
>//队列为结构体时 
>priority_queue<Person, vector<Person>, less<Person>> q；
>q.push({INF}); //假设了Person中元素都是int类型， {INF}会自动补齐所有int型元素
>//取元素
>int w = windows.top();
>windows.pop()
>```
>9. 空间换时间
>
> ```c++
> // 普通判素数
> bool isprime(int n) {
>     if (n <= 1) return false; // <= 比 == 进一步考虑了负数情况  一定要用小于等于
>     for (int i = 2; i*i <= n; i++)
>     	if(n % i == 0) return false;
>      return true;
>  }
>  // 素数表的建⽴ 1为素数
>  // ⾸先都标记为1，外层循环i从2到√n，内层循环j从2开始到i*j<n 把j的i倍都标记为0
>  vector<int> isprime(50000, 1);
>  for (int i = 2; i * i < 50000; i++)
>      for (int j = 2; j * i < 50000; j++)
>          isprime[j * i] = 0;
> ```
> 
> 10. PAT甲级1140得出经验 string res; res += 操作 比res = res + 要快 当处理非常多的时候 后者会超时
> 

  

>1. 定义字符数组，或者字符串数组，并输入时的语法
>
>```c++
>//定义字符数组时
>char names[] = "ACME" //以字符串赋值，不输入长度，会自动设置长度
>//定义二维数组时，赋初值可以用字符串
>char days[7][4] = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"};
>//二维数组也可以不指定长度，避免溢出情况
>char days[7][] = {"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"};
>// 用字符串
>string str[10];
>```
>
>2. 结构体重载运算符用sort函数比较大小
>
>```c++
>//案例一
>struct Book
>{
>    string id, name, author;
>    set<string> keywords;
>    string publisher, year;
>    bool operator < (const Book& t) const
>    {
>        return id < t.id; 
>    }
>};
>//案例二
>struct Person  // 球员
>{
>    int arrive_time, play_time;
>    int start_time, waiting_time;
>    // 同时重载了 < 和 > 运算符 cmp是用来指定用哪个符号比
>    // 优先队列定义时参数设置greater，即降序 故用 > 
>    bool operator< (const Person& t) const  // sort排序
>    {
>       if (start_time != t.start_time) return start_time < t.start_time;
>       return arrive_time < t.arrive_time;
>    }
>    bool operator> (const Person& t) const  // 优先队列中比较大小
>    {
>       return arrive_time > t.arrive_time;
>    }
>};
>```
>
>3. 字符串的一些处理函数
>
>```c++
>#include <iostream>
>#include <string>
>using namespace std;
>// 给⼀些数字字符串，求这些字符串拼接起来能够构成的最小的数字的方式
>bool cmp(string a, string b) {
>	return a + b < b + a;
>}
>int main ()
>{
>   // 字符串需要从后往前处理时困难， 可以先reverse处理 最后确定答案后记得要reverse回来
>   string str="We think in generalities, but we live in details.";
>   string rev = reverse(str.begin(), str.end());
>   string str2 = str.substr (3,5);     // "think" 3 开始向后5个
>   int pos = str.find("live");      // position of "live" in str
>   string str3 = str.substr (pos);     // get from "live" to the end
>   cout << str2 << ' ' << str3 << '\n';
>   s.earse(s.begin()); //移除字符串s的第⼀个字符
>   s.insert(0, n, '0'); //在字符串 s 前⾯增加 n 个 0 
>   a = string(5, "0"); //令a为5个”0“；
>
>   //方式一
>   printf("%s ", days[a[i] - 'A'].c_str()); //不加c_str()会乱码
>   //方式二
>   cout << days[a[i] - 'A'] << " ";
>
>   return 0;
>}
>```
>
>4. 求长度时尽量用size即可
>
>```c++
>char a[];
>strlen(a); //  得到的长度是里面真实存储了字母的⻓度，不包括 \0,
>
>string s;
>s.length(); // 返回得到unsigned int,跟int比较时有个warning,会导致WA
>s.size(); // 得到int 
>s.empty(); //判空
>
>vector<int> v;
>v.size(); //vector.size()返回的是unsigned int 类型，可能出现段错误，需要强制转换为int()
>v.empty();
>
>stack s;
>s.empty();
>```
>5. 实现hash时，何时用数组，何时用unordered_map 
>
>   ```c++
>   // 1054题中
>   //更适合用hash实现可以避免开辟颜色不存在的空间
>   unordered_map<int, int> cnt; // 定义unordered_map时不要用hash作为名称 会出现冲突
>   for (int i = 0; i < n * m; i ++ )
>   {
>       int x;
>       scanf("%d", &x);
>       //使第一次找 cnt[x] 即使x的映射从未建立，会在建立映射的同时赋初值0并＋1
>       if ( ++ cnt[x] > n * m / 2)    
>       {
>           printf("%d\n", x);
>           break;
>       }
>   }
>   //用数组实现开辟了很多无用空间 时间复杂度高
>   int color[16*1024*1024];
>   int m, n, pixel;
>   cin >> m >> n;
>   for(int i = 0; i < n; i++){
>       for(int j = 0; j < m; j++){
>           cin >> pixel;
>           color[pixel]++;
>       }
>   }
>   for(int i = 0; i < 16*1024*1024; i++){
>       if(color[i] >= m * n / 2 + 1){
>        cout<< i;
>        return 0;
>       }
>   }
>   ```
>
>6. 在计算机科学中，0x3f是十六进制数，等于63的十进制表示。63在计算机中通常表示为01111111的二进制数，其中最高位（最左边的位）为0，其他位都为1。在IEEE 754标准中，这个二进制数被用来表示正无穷大（positive infinity）。
>
>   具体来说，IEEE 754标准定义了一种称为浮点数（floating-point number）的数据类型，用于在计算机中表示实数。这种数据类型使用一种二进制科学计数法来表示实数，其中数值被表示为一个符号位、一些指数位和一些尾数位的组合。当指数位全为1时，这个浮点数就被解释为正无穷大或负无穷大，具体是哪一个取决于符号位。
>
>   因此，当二进制表示为0x3f的浮点数的符号位为0，指数位全为1，尾数位为0时，它就被解释为正无穷大。这就是为什么0x3f能表示正无穷大的原因。
>
>7. 处理链表题时 可以用struct + string 模拟链表 相比数组 e[N], ne[N], h[N]  更易于排序
>
> ```c++
> #include<unordered_map>
> #include<algorithm>
> #include<vecotor>
> struct Node{
>     string address;
>     int key;
>     string next;
>     bool operator< (const Node& n)const{
>         return key < n.key; 
>     }
> };
> unordered_map<string, Node> m；
> vector<Node> v;
> m['00001'] = {'00001', 2, '00002'};
> // 一个for循环把 连起来的Node 放进vector
> for(int i = 0; i != "-1"; i = m[i])v.push_back(m[i]) 
> // 按key排序 但有一个弊端 Node未变
> sort(v.begin(), v.end())
> // 这里输出要先判断v是否为空，可能全是离散的Node，未连入head
> // 输出下一个 节点地址不能输出next而是 i+1的address 即可达到模拟排序的效果
> for(int i = 0; i < v.size(); i++){
> 	printf("%s %d %s\n", v[i].address.c_str(), v[i].key, v[i + 1].address.c_str);  
> }
> ```
>
>9. PAT甲级 1075 一个结构体里面可以写构造函数进行初始化，在结合哈希表使用时，由一个int或string指向一个struct时需要调用构造函数，还可以写函数处理内部数据        ___重点记忆___
>
>```c++
>const int k = 6;  // 需要定一个上界
>struct student{
>    string id;
>    int grades[k], total, cnt;
>    student(){}
>    student(string _id) : id(_id){
>        for (int i = 0; i < k; i++) grades[i] = -2;
>        total = 0;
>        cnt = 0;
>    }
>    void calc(){
>        for(int i = 0; i < k; i++)
>            if(grades[i] > 0){
>                total += grades[i];
>                if(grades[i] == score[i])cnt++;
>            }
>    }
>    bool submit(){
>        for(int i = 0; i < k; i++) if(grades[i] >= 0)return true;
>        return false;
>    }
>    bool operator< (const student& s)const{
>        if(total != s.total)return total > s.total;
>        else if(cnt != s.cnt)return cnt > s.cnt;
>        return u_id < s.u_id;
>    }
>}
>unordered_map<string, student> m;
>// 在用map构造时 要调用构造函数
>if(m.count(id) == 0){
>	m[id] = student(id);
>}
>```
>
>10. 对于给定一个排序序列，判断是哪种排序：不需要从头排一遍去匹配，时间复杂度太高，根据***排序序列的特点***来确定所用排序方法
>
>  ```c++
>  //插入排序特点为 每一个序列 从前往后升序
>  //堆排序特点，从后往前每一个数都肯定比a[0]大，升序排序需要用最大堆，每次取出最大数
>  ```
>




>1. 关于字符串输入的处理：
>
>```c++
>#include<string>
>#include<sstream>
>//方式一：读取一行字符串
>string s;
>getchar(); // 在getline之前要去掉 上一行的回车
>getline(cin, s);
>//方式二：读取一行后 以空格为分界读取一行中的word 如"aaa bbb ccc"
>string line;
>getchar();
>getline(cin, line); //先将一行读入到line
>stringstream ssin(line); //把line读取到ssin缓冲区中  这里的ssin是自定义的，可以随便改
>cout << line[0];    //现在可以用 line[0]，line[1] 即以索引方式访问line中元素 包括其中的空格
>//方式三：读取到字符数组中
>#include<iostream>
>char str[100];
>getchar();
>cin.getline(str, 100); //或者是 gets(str);
>```
>
>```	c++
>//scanf输入可以快速处理带格式输入，并从中提取有效信息
>//如下快速处理 ”02：57：23 34“
>scanf("%d:%d:%d %d", &hour, &minute, &second, &service_t)  // 但是无法读取包含 E 之类的带格式输入
>//此外，涉及到时间问题时 可以统一将时刻 转成 秒数，计算时间差时 可以直接相减
>//依据时间段计算电话费那道题 用差不多的思想 先算出每一时刻的收费存入数组，计算话费只需做差，空间换时间
>```
>
>2. 关于auto的使用
>
>```c++
>auto it = s.begin(); it != s.end(); //it++在迭代遍历集合s或者映射s时
>//set 获取元素值： `*it`
>//map 获取元素值： `it->first it->second`
>int arr[4] = {0, 1, 2, 3};
>for (int i : arr)
>	cout << i << endl; // 输出数组中的每⼀个元素的值，每个元素占据⼀⾏
>for (int &i : arr) // i为引⽤变量
>	i = i * 2; // 将数组中的每⼀个元素都乘以2，arr[4]的内容变为了{0, 2, 4, 6}
>```

>1. 长整数保存为字符串 或者 字符数组 或vector
>
>```c++
>//首先为什么长整数 保存为字符串，有时候长整数的位数（19位）也不够处理，如10^100，需要字符串来辅助
>//有时候字符串 处理长整数 又会出现超时的情况， 需要用vector<int> v存储长整数
>typedef long long LL;
>//方式一 
>LL a;
>string b = to_string(a);
>//方式二
>char b[];
>while (a != 0){
>     b[i++] = a % 10;
>     a = a / 10;
> }
>//用vector 保存长整数 做高精度题 加法模板
>vector<int> add(vector<int>& a, vector<int>& b){    
>     vector<int> c;
>     for(int i = 0, t = 0; i < a.size() || i < b.size() || t; i++){
>         int s = t;
>         if(i < a.size()) s += a[i];
>         if(i < b.size()) s += b[i];
>         c.push_back(s % 10);
>         s = s /10;
>     }
>     return c;
> } //注意函数类型不能定义为 vector<int>&
>```
>
>4. 关于vector插入元素的问题
>
>```c++
>#include<vector>
>int elem;
>//方式一
>vector<int> v1;
>v.push_back(elem); //从下标 0 开始插入
>//方式二
>int len;
>vector<int> v2(len);
>v2[0] = elem; //覆盖下标0元素
>v2.push_back(elem); //前面已经有k个空间被开辟，默认赋值0，会在k+1个位置插入elem
>```
>
>5. 关于reverse函数 原型 reverse(v.begin(), v.end()) 第二个参数是要置换的元素的后一个位置.置换这一题中N是元素个数  ，M是右移位数，要考虑到M大于N的情况
>
>```c++
>#include<algorithm>
>//长度为N的向量
>reverse(v.begin(),v.begin() + N - M); //0 ~ N-M-1
>reverse(v.begin() + N - M, v.begin() + N); // N-M ~ 末尾 
>reverse(v.begin(), v.begin() + N); // 0 ~ 末尾
>```
>




> 1. 将十进制数 转为 D进制数 再逆置 再转换回十进制数， 不需要一步一步 （既需要进制来回转换，还需要考虑转到D进制数太长的问题，又要写逆置算法）可以通过规律一步到位
>
>    ```c++
>    bool check(int n, int d)
>    {
>        if (!is_prime(n)) return false;
>        LL r = 0;
>        while (n)
>        {
>            r = r * d + n % d;
>            n /= d;
>        }
>        return is_prime(r);
>    }
>    ```
>
> 2. 关于string char int 之间的转换问题
>   ```c++
> //int 转 char 利用自动转换 数字转为字符时  原理为字符底层用ASCII码存储，即ASCII码加int
> char res; 	// 这里由于res时char类型，所以后面'0' + n 原本会得到ASCII码，再转为对应字符
> int n;
> res = '0' + n; //可以将数字 0-9 转换成'0'~'9'的字符 前提是=前面是赋值给一个char类型变量
> res = 'A' + r - 10 // 如果进制超过10，以'A'为前缀进行转换
> string str;	
> //不加(char)会导致'0'+n得到ASCII码，报错信息:string与int无法相加
> str = str + char('0' + n);
> 
> //char 转 int
> char c = '6';
> int val = c - '6'
> 
> //int float LL 转 string   double, float 转换时会出现精度损失 包括double进行过多的计算时也会出现误差 可以用先*1000放大后再计算再 /1000解决 
> int n = 100; 
> string num;
> string res = to_string(n) //方式一 to_string
> while(n){
>     num += n % 10 + '0' + num;
>     n /= 10;
> }
> 
> //string 转（int, LL） cctype头文件可以将字符串转为各种类型
> #include<cctype> 
> stoi (string to int)       // "03" 可以转成3
> stod (string to double)
> stof (string to float)
> stold (string to long double)
> stol (string to long)           // long 和 long long 的区别是 ？？
> stoll (string to long long)
> stoul (string to unsigned long)
> stoull (string to unsigned long long)
>   ```
>
> 3. ```c++
>    // 求平均值并四舍五入 round
>    #include<cmath>
>    int sum, avg;
>    avg = round(sum / 5.0);
>    avg = round(sum / (float)n);// 求平均值并四舍五入
>    ```
>
> 5. 当遇到题目中出现  某集合中是否出现过 某个元素的问题时，要用hash 实现 O（1）
>
>    ```	c++
>   #include<set>
>    #include<map>
>    #include<multiset>
>    #include<multimap>
>    #include<unordered_map>
>    #include<unordered_set>
>    //以下四个以红黑树为底层实现，有序，O（logN）
>    set<int> s;
>    map<int, int> m;
>    multiset<int> ms;
>    multimap<int, int> mm;
>    //以下两个以哈希为底层实现，无序，O（1）
>    unordered_map<int, int> unm;
>     unordered_set<int, int> uns;
>    //遍历hash的例子
>     unordered_map<string, int> str;
>    for(auto item : unm){
>        item.first; //字符串
>        item.second;//出现次数
>    }
>    //⽤数组 hash[26] 或者 hash[10] 保存某个字⺟或者数字出现的次数/是否曾经出现过；⽤ hash[256] 保存某个 ASCII码 字符是否出现过， exist[10000] 、 cnt[10000] 同理
>    ```
>









